# 八种排序算法

1.排序算法概述

```
排序就是将对一组对象按照某种逻辑顺序重新排列的过程。
本文主要关注的是通过八种排序算法重新排列数组元素，其中每个元素都有一个主键。
排序算法的目标就是将所有元素的主键按照某种方式排列。
排序后索引较大的主键排在索引较小之后的主键。元素和主键的具体性质在不同的应用中千差万别。
在Java中通常都是对象，对主键的抽象描述则是通过内置的机制（Comparable接口）来完成的。
```

2. 排序算法模板

```
public class template{
    //排序算法实现函数
    public static void sort(Comparable[] a){}
    //比较两个值
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w)<0;
    }
    //交换两个值
    private static void exch(Comparable[] a,int i,int j){
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    private static void show(Comparable a){
        for(int i=0;i<a.length;i++){
            stdOut.print(a[i]+" ");
        }
        StdOut.println(0;
    }
    public static boolean isSorted(Comparable[] a){
        for(int i=1;i<a.length;i++){
            if(less(a[i],a[i-1]) return false;
        }
        return ture;
    }
    public static void main(String[] args){
        String[] a=In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```

## 一、 冒泡排序

1. 算法思想

- 参考百度百科中的定义 <https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306>

```
冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。
走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），
就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
```

2. 伪代码实现

- Java 代码

```
public static void bubbleSort(Comparable[] data) {
        for (int i = data.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (less(data[j] ,data[j + 1])) {
                    exch(data,i,j);
                }
            }
        }
    }
```

3. 性能分析

```
从代码不难看出，两层for循环，每一趟排序一个数字。每一趟需要遍历(n,n-1,n-2,...,1)个数字
所以算法复杂度为O(n^2)，空间复杂度为原地排序O(1)
```

## 二、 选择排序

1. 算法思想

```
找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。
再次，在剩下的元素中找到最小的元素，将它与素组的第二个元素交换位置。如此往复，直到将整个数组排序。
这种方法叫做选择排序，因为它在不断地选择选择元素中的最小值者。
```

2. 伪代码实现

- Java 代码

```
    public static void insertionSort(Comparable[] data) {
        int N = a.length;
        for(int i=0 ; i < N ; i++){
            int min = i;
            for(int j= i+1 ; j < N ; j++){
                if(less(a[j],a[min])){
                    min=j;
                }
            }
            exch(a, i , min);
        }
    }
```

- 代码说明

```
对于每个元素和前面一个元素比较，如果比它小，就交换两个元素，直到前面没有一个比它大的元素或者已经到达第一个元素。
```

3. 性能分析

```
两层for循环，每一次选择一个数字放到合适的位置。每一次选择可能需要交换(0，1，2，...，n-1)个数字
所以算法复杂度为O(n^2)，空间复杂度为原地排序O(1)
```

## 三、 插入排序

1. 算法思想
2. 伪代码实现

- Java 代码

```
    public static void insertionSort(Comparable[] data) {
        int N = a.length;
        for(int i=1 ; i<N ; i++){
            for(int j=i ; j > 0 &&less(a[j] , a[j-1]) ; j--){
                exch(a, j , j-1);
            }
        }
    }
```

4. 性能分析

## 四、 快速排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 五、 堆排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 六、 希尔排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 七、 归并排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 八、 基数排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 九、 Java中排序算法

##### 参考文献

> 1. 《算法4》
> 2. https://www.jianshu.com/p/c35ef9f4f2f7
> 3. https://blog.csdn.net/holmofy/article/details/71168530#t7