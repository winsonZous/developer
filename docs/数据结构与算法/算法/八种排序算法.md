# 八种排序算法

1.排序算法概述

```
排序就是将对一组对象按照某种逻辑顺序重新排列的过程。
本文主要关注的是通过八种排序算法重新排列数组元素，其中每个元素都有一个主键。
排序算法的目标就是将所有元素的主键按照某种方式排列。
排序后索引较大的主键排在索引较小之后的主键。元素和主键的具体性质在不同的应用中千差万别。
在Java中通常都是对象，对主键的抽象描述则是通过内置的机制（Comparable接口）来完成的。
```

2. 排序算法模板

```
public class template{
    //排序算法实现函数
    public static void sort(Comparable[] a){}
    //比较两个值
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w)<0;
    }
    //交换两个值
    private static void exch(Comparable[] a,int i,int j){
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    private static void show(Comparable a){
        for(int i=0;i<a.length;i++){
            stdOut.print(a[i]+" ");
        }
        StdOut.println(0;
    }
    public static boolean isSorted(Comparable[] a){
        for(int i=1;i<a.length;i++){
            if(less(a[i],a[i-1]) return false;
        }
        return ture;
    }
    public static void main(String[] args){
        String[] a=In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```

## 一、 冒泡排序

1. 算法思想

- 参考百度百科中的定义 <https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306>

```
冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。
走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），
就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
```

2. 伪代码实现

- Java 代码

```
public static void bubbleSort(Comparable[] data) {
        for (int i = data.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (less(data[j] ,data[j + 1])) {
                    exch(data,i,j);
                }
            }
        }
    }
```

3. 性能分析

```
从代码不难看出，两层for循环，每一趟排序一个数字。每一趟需要遍历(n,n-1,n-2,...,1)个数字
所以算法复杂度为O(n^2)，空间复杂度为原地排序O(1)，能够保证偶序性。
```

## 二、 选择排序

1. 算法思想

```
找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。
再次，在剩下的元素中找到最小的元素，将它与素组的第二个元素交换位置。如此往复，直到将整个数组排序。
这种方法叫做选择排序，因为它在不断地选择选择元素中的最小值者。
```

2. 伪代码实现

- Java 代码

```
    public static void insertionSort(Comparable[] data) {
        int N = a.length;
        for(int i=0 ; i < N ; i++){
            int min = i;
            for(int j= i+1 ; j < N ; j++){
                if(less(a[j],a[min])){
                    min=j;
                }
            }
            exch(a, i , min);
        }
    }
```

- 代码说明

```
对于每个元素和前面一个元素比较，如果比它小，就交换两个元素，直到前面没有一个比它大的元素或者已经到达第一个元素。
```

3. 性能分析

```
两层for循环，每一次选择一个数字放到合适的位置。每一次选择可能需要比较(n-1,n-2,...,1)个数字
所以算法复杂度为O(n^2)，空间复杂度为原地排序O(1)
```

## 三、 插入排序

1. 算法思想

```
通常人们整理桥牌的方法是一张一张的来将每一张插入到其他已经有序的牌中的适当位置。
在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。
这种算法叫做插入排序。
```

2. 伪代码实现

- Java 代码

```
    public static void insertionSort(Comparable[] data) {
        int N = a.length;
        for(int i=1 ; i<N ; i++){
            for(int j=i ; j > 0 &&less(a[j] , a[j-1]) ; j--){
                exch(a, j , j-1);
            }
        }
    }
```

4. 性能分析

```
两层for循环，把每一个数字放到合适的位置。每一次可能需要交换(0，1，2，...，n-1)个数字
算法复杂度为O(n^2)，空间复杂度为原地排序O(1)
```

## 四、 快速排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 五、 堆排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 六、 希尔排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 七、 归并排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 八、 基数排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 九、 Java中排序算法

##### 参考文献

> 1. 《算法4》
> 2. https://www.jianshu.com/p/c35ef9f4f2f7
> 3. https://blog.csdn.net/holmofy/article/details/71168530#t7