# 八种排序算法

1.排序算法概述

```
排序就是将对一组对象按照某种逻辑顺序重新排列的过程。
本文主要关注的是通过八种排序算法重新排列数组元素，其中每个元素都有一个主键。
排序算法的目标就是将所有元素的主键按照某种方式排列。
排序后索引较大的主键排在索引较小之后的主键。元素和主键的具体性质在不同的应用中千差万别。
在Java中通常都是对象，对主键的抽象描述则是通过内置的机制（Comparable接口）来完成的。
```

2. 排序算法模板

```
public class template{
    //排序算法实现函数
    public static void sort(Comparable[] a){}
    //比较两个值
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w)<0;
    }
    //交换两个值
    private static void exch(Comparable[] a,int i,int j){
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    private static void show(Comparable a){
        for(int i=0;i<a.length;i++){
            stdOut.print(a[i]+" ");
        }
        StdOut.println(0;
    }
    public static boolean isSorted(Comparable[] a){
        for(int i=1;i<a.length;i++){
            if(less(a[i],a[i-1]) return false;
        }
        return ture;
    }
    public static void main(String[] args){
        String[] a=In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```

## 一、 冒泡排序

1. 算法思想

- 参考百度百科中的定义 <https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306>

```
冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。
走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），
就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
```

2. 伪代码实现

- Java 代码

```
public static void bubbleSort(Comparable[] data) {
        for (int i = data.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (less(data[j] ,data[j + 1])) {
                    exch(data,i,j);
                }
            }
        }
    }
```

3. 性能分析

```
从代码不难看出，两层for循环，每一趟排序一个数字。每一趟需要遍历(n,n-1,n-2,...,1)个数字
所以算法复杂度为O(n^2)，空间复杂度为原地排序O(1)，能够保证偶序性。
```

## 二、 选择排序

1. 算法思想

```
找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。
再次，在剩下的元素中找到最小的元素，将它与素组的第二个元素交换位置。如此往复，直到将整个数组排序。
这种方法叫做选择排序，因为它在不断地选择选择元素中的最小值者。
```

2. 伪代码实现

- Java 代码

```
    public static void insertionSort(Comparable[] data) {
        int N = a.length;
        for(int i=0 ; i < N ; i++){
            int min = i;
            for(int j= i+1 ; j < N ; j++){
                if(less(a[j],a[min])){
                    min=j;
                }
            }
            exch(a, i , min);
        }
    }
```

- 代码说明

```
对于每个元素和前面一个元素比较，如果比它小，就交换两个元素，直到前面没有一个比它大的元素或者已经到达第一个元素。
```

3. 性能分析

```
两层for循环，每一次选择一个数字放到合适的位置。每一次选择可能需要比较(n-1,n-2,...,1)个数字
所以算法复杂度为O(n^2)，空间复杂度为原地排序O(1)
```

## 三、 插入排序

1. 算法思想

```
通常人们整理桥牌的方法是一张一张的来将每一张插入到其他已经有序的牌中的适当位置。
在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。
这种算法叫做插入排序。
```

2. 伪代码实现

- Java 代码

```
    public static void insertionSort(Comparable[] data) {
        int N = a.length;
        for(int i=1 ; i<N ; i++){
            for(int j=i ; j > 0 &&less(a[j] , a[j-1]) ; j--){
                exch(a, j , j-1);
            }
        }
    }
```

4. 性能分析

```
两层for循环，把每一个数字放到合适的位置。每一次可能需要交换(0，1，2，...，n-1)个数字
算法复杂度为O(n^2)，空间复杂度为原地排序O(1)
```

## 四、 快速排序

1. 算法思想

```
快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。当两个子数组有序时整个数组也就自然有序。
排序的具体流程：
（1）首先设定一个分界值.将数组分成左右两部分
（2）将大于分界值的数据集中到数组的右边，小于分界值的数据集中到数组的左边。
（3）然后左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值。
将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似的数据处理。
（4）重复上述过程。通过递归将左侧部分排好后，再递归排好右侧部分数据。当左右部分数据排好序后，整个数组的排序也就完成了。
```

2. 伪代码实现

```
    public static void sort(Comparable[] a){
        StdRandom.shuffle(a);
        sort(a,0,a.length);
    }
    private static void sort(Comparable[] a){
        if(high <= low) return;
        int j = partition(a,low,high);
        sort(a,low,j-1);
        sort(a,j+1,high); 
    }
    private static int partition(Comparable[] a,int low,int high){
        int i=low,j=high+1;
        Comparable v=a[low];
        while(true){
            while(less(a[++i],v)){
                if(i==high){break;}
            }
            while(less(v,a[--j])){
                if(j==low){
                    break;
                }
            }
            if(i>=j) break;
            exch(a,low,j);
        }
        return j;
    }
```

3. 性能分析

```
代码实现内部快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。
快速排序的最好情况时每次都能正好将数组对半分，这种情况下快速排序所用的比较次数正好满足分算法O（NlogN）。
最坏的情况是只能切分一个数字，这种情况下排序所用的比较次数满足O（N^2）.
但平均而言切分元素都能落在数组的中间。虽然快速排序最多需要N^2次比较，但随机打乱数组能够预防这种情况。
```

## 五、 堆排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 六、 希尔排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 七、 归并排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 八、 基数排序

1. 算法思想
2. 伪代码实现
3. 性能分析

## 九、 Java中排序算法

##### 参考文献

> 1. 《算法4》
> 2. https://www.jianshu.com/p/c35ef9f4f2f7
> 3. https://blog.csdn.net/holmofy/article/details/71168530#t7