# 进程同步与通信

## 进程间的相互作用

1. 进程间的联系

- 进程间的关系

```
资源共享关系：多个进程共享CPU和IO，并且彼此无关，它们之间并不知道其他进程存在。
相互合作关系：某些任务比如打印文件，需要多个进程协作才能完成。
```

- 临界资源

```
生产者消费者问题
生产者进程在生产产品，消费着进程在消费产品。
在他们之间设置一个具有n个缓冲区的缓冲池，生产者进程可将它生产的产品放入一个缓冲区，消费者进程可从缓冲区取得一个产品消费。
尽管他们都是按照异步方式运行，但是它们之间必须保持同步——不允许消费者进程到一个空缓冲区区消费产品，也不允许生产者进程向一个已装有产品且尚未被取走的缓冲区中投放产品。
可以通过引入计数器实现生产者消费者的同步。计数器Counter能够保证缓冲区为空就无法消费，缓冲区满载就无法生产。生产者的生产就是往缓冲区写数据，消费者消费就是往缓冲区读数据，。
对缓冲区的读写操作也是互斥。而且读写Counter和对缓冲区的读写操作也必须捆绑为原子操作，就解决生产者消费者问题。
```

- 临界区

```
硬件资源和软件资源，多个进程必须互斥地对它们进行访问
把在每个进程中访问临界资源的那段代码成为临界区，若能够保证诸进程互斥地进入自己的临界区，便可实现它们对临界资源的互斥访问。
```

- 同步机制应遵循的准则

```
(1) 空闲让进：无进程处于临界区时，相应的临界资源处于空闲状态。因而可允许一个请求进入临界区，以有效的利用资源
(2) 忙则等待：当已有进程进入自己的临界区时，意味着相应临界区的临界资源正在被访问，因而所有其他试图进入临界区的进程必须等待
(3) 有限等待：对要求访问临界资源的进程，应保证进程能在有效时间内进入自己的临界区，以免陷入死等
(4) 让权等待：当进程不能进入自己的临界区时，应当立即释放处理机，以免进程陷入忙等
```

2. 利用软件方法解决进程互斥问题
3. 利用硬件方法解决进程互斥问题
4. 信号量机制
5. 经典同步互斥问题
6. 管程机制

## 进程通信

1. 进程通信类型
2. 直接通信和间接通信
3. 消息缓冲队列通信机制

## 死锁

1. 产生死锁的原因和必要条件
2. 预防死锁
3. 避免死锁
4. 检测死锁
5. 解除死锁

## Linux进程间通信

1. Linux进程通信的基本概念
2. Linux消息队列
3. Linux的信号量
4. 共享内存
5. Linux系统调用与进程通信
6. 进程通信信号