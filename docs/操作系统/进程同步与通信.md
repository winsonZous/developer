# 进程同步与通信

## 进程间的相互作用

1. 进程间的联系

- 进程间的关系

```
资源共享关系：多个进程共享CPU和IO，并且彼此无关，它们之间并不知道其他进程存在。
相互合作关系：某些任务比如打印文件，需要多个进程协作才能完成。
```

- 临界资源

```
生产者消费者问题
生产者进程在生产产品，消费着进程在消费产品。
在他们之间设置一个具有n个缓冲区的缓冲池，生产者进程可将它生产的产品放入一个缓冲区，消费者进程可从缓冲区取得一个产品消费。
尽管他们都是按照异步方式运行，但是它们之间必须保持同步——不允许消费者进程到一个空缓冲区区消费产品，也不允许生产者进程向一个已装有产品且尚未被取走的缓冲区中投放产品。
可以通过引入计数器实现生产者消费者的同步。计数器Counter能够保证缓冲区为空就无法消费，缓冲区满载就无法生产。生产者的生产就是往缓冲区写数据，消费者消费就是往缓冲区读数据，。
对缓冲区的读写操作也是互斥。而且读写Counter和对缓冲区的读写操作也必须捆绑为原子操作，就解决生产者消费者问题。
```

- 临界区

```
硬件资源和软件资源，多个进程必须互斥地对它们进行访问
把在每个进程中访问临界资源的那段代码成为临界区，若能够保证诸进程互斥地进入自己的临界区，便可实现它们对临界资源的互斥访问。
```

- 同步机制应遵循的准则

```
(1) 空闲让进：无进程处于临界区时，相应的临界资源处于空闲状态。因而可允许一个请求进入临界区，以有效的利用资源
(2) 忙则等待：当已有进程进入自己的临界区时，意味着相应临界区的临界资源正在被访问，因而所有其他试图进入临界区的进程必须等待
(3) 有限等待：对要求访问临界资源的进程，应保证进程能在有效时间内进入自己的临界区，以免陷入死等
(4) 让权等待：当进程不能进入自己的临界区时，应当立即释放处理机，以免进程陷入忙等
```

2. 利用软件方法解决进程互斥问题

- 结论：完全利用软件的方法来解决诸进程的互斥进入临界区的问题有一定难度且有很大局限性，因而现在很少采用。

4. 利用硬件方法解决进程互斥问题

- 硬件方法实现进程互斥的原理是利用硬件指令的原子性实现资源访问操作的原子性
- 利用Test-and-Set指令实现互斥

```
每个临界资源用一个变量lock表示状态（lock==0 表示资源空闲，lock==1 表示被占用）
进程访问临界资源之前，都TestAndSet(if（lock==0）,set lock==1)
每个进程不断TestAndSet(),这样就能够实现上述说明的同步机制的准则。
```

- 利用Swap指令实现进程互斥

```
利用Swap指令实现进程互斥时，可为临界资源设置一个全局变量lock。其初值为0，在每个进程中再利用一个局部变量key。

实现进程互斥的循环进程可用伪代码描述
while（1）{
...
key=1;
do(){
    swap(lock,key)
}while(key)
lock=0;
利用硬件指令能有效实现进程互斥，却不能满足让权等待，在进程访问临界资源的过程中，会不断自旋，浪费处理机时间。
}
```

4. 信号量机制

- 记录型信号量机制

```
信号量的伪代码定义
typedef struct{
    int value;
    list of process *L;
}
void wait(semophore s){
    s.value--;
    if(s.value<0){
        block(s.L);
    }
}
void signal(static semaphore s){
    s.value++;
    if(s.value<=0){
        wakeup(s.L);
    }
}

记录型信号量机制中，s.value的初值表示系统中某类资源的数目，因而又称资源的信号量。
wait（）和signal（）都是原子操作。
每次wait操作意味着进程请求一个单位的资源，进程请求一个单位的资源，因此描述为s.value--;
当s.value<0时，表示资源已分配完毕，因而进程调用block原语，进行自我阻塞，放弃处理机并插入到信号量链表中。
该机制遵循了让权等待准则。此时s.value--的绝对值表示在该信号量链表中已阻塞进程的数目。
每次signal操作，表示执行进程释放一个单位资源，故s.value++操作表示资源数目加1。
若加 1后仍是s.value<=0,则表示在该信号量链表中仍有等待该资源的进程被阻塞，故还应还调用wakeup原语，唤醒进程访问临界资源。
结论：为临界资源设置一信号量mutex，并设置初始值为1，然后将个进程的临界区CS置于wait（mutex）和signal（mutex）操作之间就能使多个进程能互斥地访问某临界资源。
```

- 信号量集机制

```
AND型信号量集机制，上述的记录型信号量机制使针对进程之间要共享一个临界资源而言的。当一个进程需要获得多个共享资源后方能执行任务，这样就容易出现死锁。
AND信号量同步机制的基本思想使：将进程在整个运行过程中所需要的所有临界资源一次性全部分配给进程，待该进程使用完后在一起释放。
```

5. 经典同步互斥问题

- 生产者-消费者问题

```
利用记录型信号量解决生产者消费者问题
假设生产者和消费者之间的公用缓冲池中有n个缓冲区，可利用互斥信号量mutex使诸进程实现对缓冲池的互斥使用。
利用资源信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区，可用伪代码描述如下：

semaphore mutex,full=0,empty=n;
item buffer(n);
int in=out=0;

void producer(int i){
    while(1){
        ...
        produce an item in nextp;
        ...
        wait(empty);
        wait(mutex)
        buffer(in)=nextp;
        in= (in+1) mod n;
        signal(mutex);
        signal(full);
    }
}
void consumer(){
    while(1){
        ...
        wait(full);
        wait(mutex);
        nextc=buffer[out];
        out=(out+i) mod n;
        siganl(mutex);
        signal(empty);
        consumer the item in nextc;
    }
}
```

- 读写者问题

```
一个数据文件或记录可被多个进程共享。把只要读的进程成为“读者进程”，进行写或者修改的进程称为“写着进程”。
允许多个读者进程同时读一个共享对象，因为读操作不会使数据文件混乱，但决不允许一个写着进程和其他读者进程或者写者同时访问共享对象。
读者-写者问题是只保证一个写者进程必须与其他进程互斥访问共享对象的同步问题。读者与写者争夺访问共享数据时可以具有不同的优先权，因此又分为读者优先和写者优先。
(1) 
//用于多个读者同步的信号量 wait(rmutex)、signal(rmutex)之间对readcount的操作能保证进程间互斥
semaphore rmutex=1;
//用于读写者之间同步的信号量
semaphore mutex=1;
int readcount=0;
void reader(int i){
    while(1){
        wait(rmutex);
        if(readcount==0) //没有读者的时候可能有写者，所以需要先在mutex下等待
            wait(mutex);
        readcount++;
        signal(rmutex);
        perform read operation;
        wait(rmutex);
        readcount--; 
        if(readcount==0) //自己已是最后一个读者，需要唤醒写者
            signal(mutex)
        signal(rmutex);
    }
}

void writer(){
    wait(mutex);
    perform write operation;
    signal(mutex);
}

```

- 哲学家就餐问题

```
哲学家进餐问题是典型的同步问题，有5个哲学家，他们的生活方式是交替的进行思考和进餐;哲学家们共用一张圆桌，坐在周围的5张椅子上；
在圆桌上5个碗和5支筷子，平时哲学家进行思考，饥饿时便试图取用他左右最靠近他的筷子只有在他拿到两支筷子时才能进餐；进餐完毕后，放下筷子继续思考。
（1）记录型信号量机制来解决哲学家进餐问题
筷子总信号量为4，5个哲学家，这样总能保证有一个哲学家能同时拥有两个筷子，避免死锁
semaphore mutex=4;
void philosopher(int i){
    while(1){
        wait(mutex);
        ...
        eat;
        ...
        signal(mutex);
        think;
    }
}
main(){
    philosopher(0);
    philosopher(1);
    philosopher(2);
    philosopher(3);
    philosopher(4);
}
（2） 利用AND信号量机制解决哲学家就餐问题
一次性请求两个筷子才开始执行任务
semaphore chopstick[5]={1,1,1,1,1};
void philosoppher(int i)
{
    while(1){
        swait(chopstick[(i+1) mod 5],chopstick[i]);
        ...
        eat;
        ...
        singal(chopstick[(i+1) mod 5]);
        think;
    }
}
main(){
    cobegin{
        philosopher(0);
        philosopher(1);
        philosopher(2);
        philosopher(3);
        philosopher(4);
    }
}

- 嗜睡的理发师问题
一个理发店由一个有N张沙发的等候室和一个放有一张理发椅的理发室组成。没有顾客要理发时，理发师便去睡觉。
当有一个顾客走进理发店时，如果等候室的所有沙发都已占用，便离开理发店否则，如过理发师正在为其他顾客理发，则该顾客就找一张空沙发坐下等待。如果理发师因无顾客正在睡觉
则由新到的顾客唤醒理发师为其理发。
分析顾客进程和理发师进程并发具体情况如下:
（1）只有理发椅空闲时，顾客才能做到理发椅上等待理发师理发，否则顾客便必须等待；只有当理发椅上有顾客时，理发师才可以开始理发，否则他也必须等待；
可通过信号量customers和barbers来控制
（2）设置一个整型变量waiting来对理发店中等待在沙发上的顾客进行计数，该变量将被多个顾客进程互斥地访问并访问，可通过一个互斥信号量mutex来实现

semaphore customer=0;
semaphore barbers=0;
semaphore mutex=0;
int waiting=0;

//理发师进程
barber(){
    while(1){
        ...
        wait(customer);//等待有客户
        wait(mutex);//尝试修改waiting变量
        waiting=waiting-1;
        signal(barbers);//唤醒理发师
        signal(mutex);//waiting变量修改结束
        cut_Hair();
        ...
    }
}
//客户进程
Customer(int i){
    ...
    wait(mutex);//尝试修改waiting变量
    if(waiting<N){
        waiting=waiting+1;
        signal(customers);
        signal(mutex);
        wait(barbers);
        have a haircut    
    }else{
        signal(mutex);
    }
    leave;
    
    ...
}
main (){
    barber();
    Customer(1);
    Customer(2);
    ...
    Customer(n);
}
```

6. 管程机制

```
（1）信号量机制是一种既方便又有效的进程同步机制，但是每个要访问临界资源的进程都必须自备同步操作wait(s)和signal(s),这就使大量同步操作分散在各个进程中。
这不仅给系统的管理带来麻烦，而且还会因同步操作的使用不当而导致系统死锁。如果把所有进程对某一种临界资源的同步操作都集中起来，构成一个所谓的秘书进程。
凡是访问该临界资源的资源，都需要先报告秘书，由秘书里实现进程的同步。
（2）管程概念
系统中的各种硬件资源和软件资源，均可用数据结构加以抽象的描述，即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。
当共享资源用
共享数据结构表示时，资源管理程序可用对数据结构进行操作的一组过程来表示。如资源的请求和释放过程request和release。这样一组相关的数据结构和过程一并称为管程。
古管程由三部分组成：
局部于管程的共享变量说明
对该数据结构进行操作的一组过程
对局部于管程的数据设置为初值的语句


```

## 进程通信

```
进程通信是指进程之间的信息交换。其所交换的信息量少则是一个状态或数值，多则成千上万个字节。
进程的互斥和同步可归结为低级通信。在进程互斥中，进程通过修改信号量向其他进程表明临界资源是否可用。信号量是一种低级通信方式

```

1. 进程通信类型

```
   （1）共享存储器系统
   基于共享数据结构的通信方式
   基于共享储存区的通信方式
   （2）消息传递系统
   直接通信方式：发送进程直接将消息发送给接收进程并将它挂在接受进程的消息缓冲队列上
   间接通信方式：发送进程将消息发送到中间实体，接受进程，从中拉取消息消费
   （3）管道通信
   管道是指用于连接一个读进程和一个写进程以及实现它们之间通信的共享文件
```

3. 直接通信和间接通信

```
直接通信方式是指发送进程利用操作系统所提供的发送命令直接把消息发送给目标进程。此时要求发送进程和接收进程都以显示的方式提供对方的标识符
```

4. 消息缓冲队列通信机制

```
间接通信方式是指进程间的通信需要通过作为某种共享数据结构的实体，该实体用来暂存发送进程发送给目标进程的消息.
接收进程则从该实体中去取对方发送给自己的消息。通常把这种中间实体称为信箱，信箱分为私有信箱，公有信箱、共享信箱。
在利用信箱通信时，在发送进程和接收进程之间存在下述四种关系：
（1) 一对一关系：进程间建立专用通信链路
（2）多对一关系：客户端/服务端关系
（3）一对多关系：广播方式方式
（4）多对多关系：建立公用信箱。多个进程都能向信箱中投递消息，也可以从信箱中取走消息

这四种也是进程间存在的对应的关系。对于这种消息队列可以参考RabbitMQ的Exchange之间的关系
```

## 死锁

1. 产生死锁的原因和必要条件
2. 预防死锁
3. 避免死锁
4. 检测死锁
5. 解除死锁

## Linux进程间通信

1. Linux进程通信的基本概念
2. Linux消息队列
3. Linux的信号量
4. 共享内存
5. Linux系统调用与进程通信
6. 进程通信信号