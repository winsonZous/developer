# 进程同步与通信

## 进程间的相互作用

1. 进程间的联系

- 进程间的关系

```
资源共享关系：多个进程共享CPU和IO，并且彼此无关，它们之间并不知道其他进程存在。
相互合作关系：某些任务比如打印文件，需要多个进程协作才能完成。
```

- 临界资源

```
生产者消费者问题
生产者进程在生产产品，消费着进程在消费产品。
在他们之间设置一个具有n个缓冲区的缓冲池，生产者进程可将它生产的产品放入一个缓冲区，消费者进程可从缓冲区取得一个产品消费。
尽管他们都是按照异步方式运行，但是它们之间必须保持同步——不允许消费者进程到一个空缓冲区区消费产品，也不允许生产者进程向一个已装有产品且尚未被取走的缓冲区中投放产品。
可以通过引入计数器实现生产者消费者的同步。计数器Counter能够保证缓冲区为空就无法消费，缓冲区满载就无法生产。生产者的生产就是往缓冲区写数据，消费者消费就是往缓冲区读数据，。
对缓冲区的读写操作也是互斥。而且读写Counter和对缓冲区的读写操作也必须捆绑为原子操作，就解决生产者消费者问题。
```

- 临界区

```
硬件资源和软件资源，多个进程必须互斥地对它们进行访问
把在每个进程中访问临界资源的那段代码成为临界区，若能够保证诸进程互斥地进入自己的临界区，便可实现它们对临界资源的互斥访问。
```

- 同步机制应遵循的准则

```
(1) 空闲让进：无进程处于临界区时，相应的临界资源处于空闲状态。因而可允许一个请求进入临界区，以有效的利用资源
(2) 忙则等待：当已有进程进入自己的临界区时，意味着相应临界区的临界资源正在被访问，因而所有其他试图进入临界区的进程必须等待
(3) 有限等待：对要求访问临界资源的进程，应保证进程能在有效时间内进入自己的临界区，以免陷入死等
(4) 让权等待：当进程不能进入自己的临界区时，应当立即释放处理机，以免进程陷入忙等
```

2. 利用软件方法解决进程互斥问题

- 结论：完全利用软件的方法来解决诸进程的互斥进入临界区的问题有一定难度且有很大局限性，因而现在很少采用。

4. 利用硬件方法解决进程互斥问题

- 硬件方法实现进程互斥的原理是利用硬件指令的原子性实现资源访问操作的原子性
- 利用Test-and-Set指令实现互斥

```
每个临界资源用一个变量lock表示状态（lock==0 表示资源空闲，lock==1 表示被占用）
进程访问临界资源之前，都TestAndSet(if（lock==0）,set lock==1)
每个进程不断TestAndSet(),这样就能够实现上述说明的同步机制的准则。
```

- 利用Swap指令实现进程互斥

```
利用Swap指令实现进程互斥时，可为临界资源设置一个全局变量lock。其初值为0，在每个进程中再利用一个局部变量key。

实现进程互斥的循环进程可用伪代码描述
while（1）{
...
key=1;
do(){
    swap(lock,key)
}while(key)
lock=0;
利用硬件指令能有效实现进程互斥，却不能满足让权等待，在进程访问临界资源的过程中，会不断自旋，浪费处理机时间。
}
```

4. 信号量机制

- 记录型信号量机制

```
信号量的伪代码定义
typedef struct{
    int value;
    list of process *L;
}
void wait(semophore s){
    s.value--;
    if(s.value<0){
        block(s.L);
    }
}
void signal(static semaphore s){
    s.value++;
    if(s.value<=0){
        wakeup(s.L);
    }
}

记录型信号量机制中，s.value的初值表示系统中某类资源的数目，因而又称资源的信号量。
wait（）和signal（）都是原子操作。
每次wait操作意味着进程请求一个单位的资源，进程请求一个单位的资源，因此描述为s.value--;
当s.value<0时，表示资源已分配完毕，因而进程调用block原语，进行自我阻塞，放弃处理机并插入到信号量链表中。
该机制遵循了让权等待准则。此时s.value--的绝对值表示在该信号量链表中已阻塞进程的数目。
每次signal操作，表示执行进程释放一个单位资源，故s.value++操作表示资源数目加1。
若加 1后仍是s.value<=0,则表示在该信号量链表中仍有等待该资源的进程被阻塞，故还应还调用wakeup原语，唤醒进程访问临界资源。
结论：为临界资源设置一信号量mutex，并设置初始值为1，然后将个进程的临界区CS置于wait（mutex）和signal（mutex）操作之间就能使多个进程能互斥地访问某临界资源。
```

- 信号量集机制

```
AND型信号量集机制，上述的记录型信号量机制使针对进程之间要共享一个临界资源而言的。当一个进程需要获得多个共享资源后方能执行任务，这样就容易出现死锁。
AND信号量同步机制的基本思想使：将进程在整个运行过程中所需要的所有临界资源一次性全部分配给进程，待该进程使用完后在一起释放。
```

5. 经典同步互斥问题

- 生产者-消费者问题

```
利用记录型信号量解决生产者消费者问题
假设生产者和消费者之间的公用缓冲池中有n个缓冲区，可利用互斥信号量mutex使诸进程实现对缓冲池的互斥使用。
利用资源信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区，可用伪代码描述如下：

semaphore mutex,full=0,empty=n;
item buffer(n);
int in=out=0;

void producer(int i){
    while(1){
        ...
        produce an item in nextp;
        ...
        wait(empty);
        wait(mutex)
        buffer(in)=nextp;
        in= (in+1) mod n;
        signal(mutex);
        signal(full);
    }
}
void consumer(){
    while(1){
        ...
        wait(full);
        wait(mutex);
        nextc=buffer[out];
        out=(out+i) mod n;
        siganl(mutex);
        signal(empty);
        consumer the item in nextc;
    }
}
```

- 读写者问题

```
一个数据文件或记录可被多个进程共享。把只要读的进程成为“读者进程”，进行写或者修改的进程称为“写着进程”。
允许多个读者进程同时读一个共享对象，因为读操作不会使数据文件混乱，但决不允许一个写着进程和其他读者进程或者写者同时访问共享对象。
读者-写者问题是只保证一个写者进程必须与其他进程互斥访问共享对象的同步问题。读者与写者争夺访问共享数据时可以具有不同的优先权，因此又分为读者优先和写者优先。
(1) 
//用于多个读者同步的信号量 wait(rmutex)、signal(rmutex)之间对readcount的操作能保证进程间互斥
semaphore rmutex=1;
//用于读写者之间同步的信号量
semaphore mutex=1;
int readcount=0;
void reader(int i){
    while(1){
        wait(rmutex);
        if(readcount==0) //没有读者的时候可能有写者，所以需要
            wait(mutex);
        readcount++;
        signal(rmutex);
        perform read operation;
        wait(rmutex);
        readcount--; 
        if(readcount==0) //自己已是最后一个读者，需要唤醒写者
            signal(mutex)
        signal(rmutex);
    }
}

void writer(){
    wait(mutex);
    perform write operation;
    signal(mutex);
}

```

- 哲学家就餐问题

```

```

6. 管程机制

## 进程通信

1. 进程通信类型
2. 直接通信和间接通信
3. 消息缓冲队列通信机制

## 死锁

1. 产生死锁的原因和必要条件
2. 预防死锁
3. 避免死锁
4. 检测死锁
5. 解除死锁

## Linux进程间通信

1. Linux进程通信的基本概念
2. Linux消息队列
3. Linux的信号量
4. 共享内存
5. Linux系统调用与进程通信
6. 进程通信信号