# 并发编程

## 一、基础知识

### 上下文切换与死锁

1. 上下文切换

```
CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。
但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时可以再加载这个任务的状态。
所以任务从保存到再加载的过程就是一次上下文切换。但是上下文会影响多线程的执行速度。

```

2. 如何减少上下文切换

- 无锁并发编程

```
多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁。
如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
```

- CAS算法

```
Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
```

- 使用最少线程

```
避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待的状态。
```

- 使用协程

```
在单线程里实现多任务的调度，并在单线程里维持多个任务
```

### 死锁

1. 死锁案例

```
public class DeadLockDemo {
    private static String A = "A";
    private static String B = "B";

    public static void main(String[] args) {
        new DeadLockDemo().deadLock();
    }

    private void deadLock() {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (A) {
                    try {
                        Thread.currentThread().sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (B) {
                        System.out.println("1");
                    }
                }
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (B) {
                    try {
                        Thread.currentThread().sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (A) {
                        System.out.println("2");
                    }
                }
            }
        });
        t1.start();
        t2.start();
    }
}

死锁的原因是因为线程错误的加锁顺序导致的
```

2. 避免死锁的常见方法

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部加锁机制。满足操作系统里的同步机制的有限等待条件。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败

3. 资源限制的挑战

- 资源限制：程序执行速度受限于计算机硬件资源或软件资源
- 资源限制引发的问题：受限于资源，并发执行不会加快速度。反而会更慢，因为增加了上下文切换和资源调度的时间。
- 如何解决资源限制的问题：对于硬件资源的限制，可以考虑集群部署。对于软件资源的限制，可以考虑使用资源池将资源复用。
- 资源限制情况下的并发编程：根据不同的资源限制调整程序的并发度

### Java并发机制的底层实现原理

1. volatile的应用

- volatile的定义

```
Java语言规范第3版中定义如下：
Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。
Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明为成volatile，Java线程内存模型确保所有线程看到这个变量的值时一致的。
```

- volatile实现原理

```
volatile 修饰的变量进行写操作会增加如下的汇编代码
0x01a3de24: lock addl $0×0,(%esp);
Lock前缀的指令在多核处理器会引发两件事
（1）当前处理器缓存行的数据写回到系统内存
（2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

首先，计算机系统为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，
如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的
数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。
所以在多处理器下，为了保证多个处理器的缓存时一致的，就会实现缓存的一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态呢，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。
```

2. synchronized实现原理与应用

```
Java中利用synchronized实现同步的基础：Java中的每个对象都可以作为锁。
具体通过以下三种方式：普通同步方法，锁是当前实例对象。对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchronized括号内配置的对象。当一个线程试图访问同步代码块时，它必须首先得到锁。
退出异常时必须释放锁。Synchronized在JVM里的实现原理，是基于进入和退出Monitor对象来实现方法同步和代码同步。
代码块的同步则是使用monitorenter和monitorexit指令实现的。虽然有所不同，但是方法同步也可以通过这两个指令来实现。
monitorenter指令狮子编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束出和异常处。
线程执行到monitorenter指令时，会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。
synchronized用的锁时存在Java对象头里的。
```

- Java对象头

```
Java对象保存到内存中，由以下三部分组成：对象头、实例数据、对齐填充字节
对象头由三部分组成：Mark Word、指向类的指针、数组长度（只有数组对象才有）
```

- 锁的升级与对比

```
Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入偏向锁和轻量级锁。
级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。
这几个状态会随着竞争情况逐渐升级但不能降级，意味着偏向锁升级轻量级锁后不能降级为偏向锁。
（1）偏向锁
现象：大多数情况下，锁不仅存在多线程竞争，而且总是由同一线程多次获得，为了线程获得锁的代价更低而引入了偏向锁。
偏向锁加锁：
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，
只需要进行CAS操作来加锁和解锁
偏向锁撤销：
偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
偏向锁的撤销，需要等待全局安全点Stop the world。
它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态。
如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录。
栈中的锁记录和对象头Mark Word要么重新偏向与其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
（2）轻量级锁
```

- 原子操作实现原理

### Java内存模型

```
在并发编程中，需要处理两个关键问题，线程间通信以及线程间同步。
```

### Java中的线程

###         

## 并发编程实战与运用

### Java并发容器与框架

### Java中的13个原子操作类

### Java中的并发工具类

### 线程池与Executor框架

### Java并发编程实践

##### 参考

1. 《深入理解Java虚拟机》
2. 《并发编程实战》
3. 《Java并发编程的艺术》