# 并发编程

## 一、基础知识

### 上下文切换与死锁

1. 上下文切换

```
CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。
但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时可以再加载这个任务的状态。
所以任务从保存到再加载的过程就是一次上下文切换。但是上下文会影响多线程的执行速度。

```

2. 如何减少上下文切换

- 无锁并发编程

```
多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁。
如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
```

- CAS算法

```
Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
```

- 使用最少线程

```
避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待的状态。
```

- 使用协程

```
在单线程里实现多任务的调度，并在单线程里维持多个任务
```

### 死锁

1. 死锁案例

```
public class DeadLockDemo {
    private static String A = "A";
    private static String B = "B";

    public static void main(String[] args) {
        new DeadLockDemo().deadLock();
    }

    private void deadLock() {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (A) {
                    try {
                        Thread.currentThread().sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (B) {
                        System.out.println("1");
                    }
                }
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (B) {
                    try {
                        Thread.currentThread().sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (A) {
                        System.out.println("2");
                    }
                }
            }
        });
        t1.start();
        t2.start();
    }
}

死锁的原因是因为线程错误的加锁顺序导致的
```

2. 避免死锁的常见方法

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部加锁机制。满足操作系统里的同步机制的有限等待条件。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败

3. 资源限制的挑战

- 资源限制：程序执行速度受限于计算机硬件资源或软件资源
- 资源限制引发的问题：受限于资源，并发执行不会加快速度。反而会更慢，因为增加了上下文切换和资源调度的时间。
- 如何解决资源限制的问题：对于硬件资源的限制，可以考虑集群部署。对于软件资源的限制，可以考虑使用资源池将资源复用。
- 资源限制情况下的并发编程：根据不同的资源限制调整程序的并发度

### Java并发机制的底层实现原理

1. volatile的应用

- volatile的定义

```
Java语言规范第3版中定义如下：
Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。
Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明为成volatile，Java线程内存模型确保所有线程看到这个变量的值时一致的。
```

- volatile实现原理

```
volatile 修饰的变量进行写操作会增加如下的汇编代码
0x01a3de24: lock addl $0×0,(%esp);
Lock前缀的指令在多核处理器会引发两件事
（1）当前处理器缓存行的数据写回到系统内存
（2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

首先，计算机系统为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，
如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的
数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。
所以在多处理器下，为了保证多个处理器的缓存时一致的，就会实现缓存的一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态呢，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存中。
```

2. synchronized实现原理与应用

- Java对象头
- 锁的升级与对比
- 原子操作实现原理

### Java内存模型
```
在并发编程中，需要处理两个关键问题，
```
### Java中的线程

### 

## 并发编程实战与运用

### Java并发容器与框架

### Java中的13个原子操作类

### Java中的并发工具类

### 线程池与Executor框架

### Java并发编程实践